{"version":3,"names":[],"mappings":"","sources":["bundle.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({\"./public/js/app.js\":[function(require,module,exports){\nrequire('./modules/var');\nvar searchBox = require('./modules/searchBox');\nvar table = require('./modules/table');\n\n// Set up the default entry point for API calls\nproteomicsURL = 'http://localhost:3000/search?';\n// proteomicsURL = 'http://massive.broadinstitute.org:3000/search?';\n\n// build the search box and autocomplete\nsearchBox.build();\n\n// build the tables\npathTable = table.buildTable('#pathTable',\n  [\n    { id: \"path\", name: \"File Path\", field:\"path\",sortable: true}\n  ]\n);\n\nevidenceTable = table.buildTable('#evidenceTable',\n  [\n    { id: \"sequence\", name: \"Sequence\", field:\"sequence\",sortable: true},\n    { id: \"modifications\", name: \"Modifications\", field:\"modifications\",sortable: true},\n    { id: \"count\", name: \"Count\", field:\"count\",sortable: true},\n    { id: \"totInten\", name: \"Total Intensity\", field:\"totInten\",sortable: true},\n    { id: \"avgInten\", name: \"Average Intensity\", field:\"avgInten\",sortable: true},\n  ]\n);\n\n\n/*****************\n * table setup *\n *****************/\n// evidenceDataView = new Slick.Data.DataView({ inlineFilters: true });\n// pathDataView = new Slick.Data.DataView({ inlineFilters: true });\n//\n// evidenceTableColumns = [\n//   { id: \"sequence\", name: \"Sequence\", field:\"sequence\",sortable: true},\n//   { id: \"modifications\", name: \"Modifications\", field:\"modifications\",sortable: true},\n//   { id: \"count\", name: \"Count\", field:\"count\",sortable: true},\n//   { id: \"totInten\", name: \"Total Intensity\", field:\"totInten\",sortable: true},\n//   { id: \"avgInten\", name: \"Average Intensity\", field:\"avgInten\",sortable: true},\n// ];\n// pathTableColumns = [\n//   { id: \"path\", name: \"File Path\", field:\"path\",sortable: true},\n// ];\n//\n// evidenceTableOptions = {\n//   enableColumnReorder: false,\n//   multiColumnSort: true,\n//   forceFitColumns: true,\n// };\n// pathTableOptions = {\n//   enableColumnReorder: false,\n//   multiColumnSort: true,\n//   forceFitColumns: true,\n// };\n//\n// evidenceTable = new Slick.Grid('#evidenceTable',\n//   evidenceDataView,\n//   evidenceTableColumns,\n//   evidenceTableOptions);\n// pathTable = new Slick.Grid('#pathTable',\n//   pathDataView,\n//   pathTableColumns,\n//   pathTableOptions);\n//\n// evidenceTable.onSort.subscribe(function (e, args) {\n//     evidenceTableSorter(e,args);\n//   });\n// pathTable.onSort.subscribe(function (e, args) {\n//     pathTableSorter(e,args);\n//   });\n\n\n/*************\n * App setup *\n *************/\n$('#apiError').css('opacity',0);\n$('#evidenceContainer').css('opacity',0);\n$('#pathTable').css('opacity',0);\n$('#evidenceTableTSV').click(function(){exportTable(evidenceTable);});\n$('#evidenceTableCSV').click(function(){exportTable(evidenceTable, 'csv');});\n$('#evidenceTablePNG').click(function(){exportTable(evidenceTable, 'png');});\n\n// try to make a call to the proteomics API and let the user know if it fails\n$.ajax({\n  dataType: 'jsonp',\n  url: proteomicsURL,\n  data: {q:'{}',l:1},\n  error: function (jqXHR, textStatus) {\n    if (textStatus === 'error'){\n      $('#apiError').animate({'opacity':1},600);\n    }else{\n      console.log(jqXHR);\n    }\n  }\n});\n\n\n\n/*********************\n * Utility Functions *\n *********************/\n\n/**\n * Utility to handle search strings input into the search box\n * @param {string} e the string that should be searched\n */\nhandleSearch = function handleSearch (e) {\n  var parenChars = ['(',')'];\n  parenChars.forEach(function(char) {\n    e.val = e.val.split(char).join('\\\\\\\\' + char);\n  });\n\n  if (e.val.length){\n    var fieldMap = {\n      '': 'gene names',\n      Gene:'gene names',\n      Modification: 'modifications',\n      Protein: 'protein names'\n    }\n\n      params = {\n        q: ['{\"',fieldMap[e.type],'\":{\"$regex\":\"^',e.val,'\", \"$options\":\"i\"}}'].join(''),\n        f: '{\"modified sequence\":1,\"intensity\":1,\"modifications\":1}',\n        col: '[\"evidence\"]',\n        l: 1000\n      }\n\n      $.ajax({\n        dataType: 'jsonp',\n        url: [proteomicsURL],\n        data: params,\n        success: function (res) {\n          $('#apiError').animate({'opacity':0},600);\n\n          var elements  = [], seqCounts = [], mods = [],\n              sequences = [], intenSums = [], evidenceData = [];\n\n          _.keys(res).forEach(function(key,i){\n            res[key].forEach(function(element,j){\n              elements.push(element);\n            });\n          })\n\n          seqCounts = _.countBy(elements, function (element) {\n            return element['modified sequence'];\n          });\n\n          // Populate array grouped on sequence\n          // \"ABCDEFG\":[{id:123, sequence:\"ABCDEFG\", intensity:456}\n          //            {id:234, sequence:\"ABCDEFG\", intensity:567}]\n          sequences = _.groupBy(elements, function (element) {\n            return element['modified sequence'];\n          });\n\n          // Populate intensity sum and modification arrays\n          _.keys(sequences).forEach(function(sequence){\n\n            // Modification\n            mods[sequence] = [];\n            for (obj in sequences[sequence]){\n              if (sequences[sequence][obj].modifications){\n                mods[sequence].push(sequences[sequence][obj].modifications);\n              }\n            }\n            mods[sequence] = _.uniq(mods[sequence]);\n\n            // Intensity\n            intenSums[sequence] = _.reduce(sequences[sequence], function(memo, obj){\n              if (obj.intensity)\n                return memo + obj.intensity;\n              else\n                return memo + 0;\n            }, 0);\n\n          })\n\n          _.keys(seqCounts).forEach(function(seq,i){\n            var avg = (intenSums[seq]/seqCounts[seq]);\n            evidenceData.push({id:i,sequence:seq,modifications:mods[seq],count:seqCounts[seq],totInten:intenSums[seq],avgInten:avg});\n          })\n\n          table.updateTable(evidenceTable,evidenceData);\n          table.resizeTable(evidenceTable);\n\n          if (evidenceTable.data.length){\n            $('#evidenceContainer').animate({opacity:1},600);\n          }else{\n            $('#evidenceContainer').animate({opacity:0},600);\n          }\n          },\n        error: function (jqXHR, textStatus) {\n          if (textStatus === 'error'){\n            $('#apiError').animate({'opacity':1},600);\n            $('#evidenceContainer').animate({opacity:0},600);\n          }else{\n            console.log(jqXHR);\n          }\n        }\n      });\n\n\n    params = {\n      q: ['{\"',fieldMap[e.type],'\":{\"$regex\":\"^',e.val,'\", \"$options\":\"i\"}}'].join(''),\n      l: 1000\n    }\n\n    $.ajax({\n      dataType: 'jsonp',\n      url: proteomicsURL.slice(0,-1) + '/experiments?',\n      data: params,\n      success: function (res) {\n        var pathData = [];\n\n        $('#apiError').animate({'opacity':0},600);\n\n        res.forEach(function(element,j){\n          pathData.push(_.extend(element,{id:element._id}));\n        });\n\n        table.updateTable(pathTable, pathData);\n        table.resizeTable(pathTable);\n\n        if (pathTable.data.length) {\n          $('#pathTable').animate({opacity:1},600);\n        }else{\n          $('#pathTable').animate({opacity:0},600);\n        }\n      },\n      error: function (jqXHR, textStatus) {\n        if (textStatus === 'error'){\n          $('#apiError').animate({'opacity':1},600);\n          $('#pathTable').animate({opacity:0},600);\n        }else{\n          console.log(jqXHR);\n        }\n      }\n    });\n\n  }else{\n    table.updateTable(evidenceTable, []);\n    table.updateTable(pathTable, []);\n    $('#evidenceContainer').animate({opacity:0},600);\n    $('#pathTable').animate({opacity:0},600);\n  }\n}\n\nhandleSearchThrottled = _.throttle(handleSearch,1000,{leading:false});\n\n\n/**\n * Utility function to mock the results of a query typed into the search searchbox\n * @param {search} searchString the string that should be mocked\n */\nhandleSearchMock = function handleSearchMock (searchString) {\n  var results = [],\n      _i;\n\n  if (searchString){\n    for (_i = 0; _i < 1000; _i++){\n      results.push({id: 'MockData' + Math.round(Math.random() * 1000000000), value: Math.random()});\n    }\n    $('#evidenceContainer').animate({opacity:1},600);\n    data = results;\n    updateTables();\n  }else{\n    $('#evidenceContainer').animate({opacity:0},600);\n    setTimeout( function () {\n      data = results;\n      updateTables();\n    },600);\n  }\n};\n\n\n/**\n * Utility to draw sequence diagrams based on the sequences observed\n */\nfunction drawSequences() {\n  var $container = $('#sequenceViews'),\n      $sequenceViews = $container.children();\n      sequences = _.pluck(evidenceTable.getData().getItems(),'sequence');\n\n  $sequenceViews.each(function() {\n    $(this).finish();\n    $(this).animate({'opacity':0}, 600);\n    setTimeout(function(){\n      $container.empty();\n    },600);\n  });\n\n  setTimeout(function(){\n    sequenceViews = [];\n    sequenceModels = [];\n    $container.finish();\n    $container.css('opacity',0);\n\n    sequences.forEach(function(sequence,i) {\n      var id = 'sequence' + i;\n      $container.append('<div id=\"' + id + '\" class=\"col-xs-4\"></div>');\n      sequenceModels.push(new Barista.Models.SequenceModel());\n      sequenceViews.push(new Barista.Views.SequenceView({el:$('#' + id), model: sequenceModels[i], png: false}));\n      sequenceViews[i].model.set({sequence:sequence});\n    });\n    $container.animate({'opacity':1},600);\n  }, 600);\n\n}\n\n/**\n * Utility to export the content of a dataView to a tab separated value table\n * @param {SlickGrid table} table the table to export\n * @param {string} the method to export the table. Valid options are 'tsv' and 'csv'. Defaults to 'tsv'\n */\nfunction exportTable(table,method) {\n  var exportString,\n      blob,\n      timestamp,\n      joiner,\n      lines = [],\n      timestamp = new Date().getTime(),\n      data = table.getData().getItems(),\n      dataLength = data.length,\n      headers = _.pluck(table.getColumns(),'field');\n\n  // make sure we have a method set up\n  method = (method === undefined) ? 'tsv' : method;\n\n  // if the method is png, download the table as a png image,\n  // otherwise download it as a text file\n  if (method === 'png') {\n    html2canvas(table.getContainerNode(), {\n      onrendered: function(canvas) {\n        var ctx = canvas.getContext(\"2d\");\n        // ctx.scale(10,10);\n        canvas.toBlob(function(blob) {\n            saveAs(blob, \"ProteomicsCrawler\" + timestamp + \".png\");\n        });\n      }\n    });\n\n  } else {\n    switch (method) {\n      case 'tsv':\n        joiner = '\\t';\n        loaderID = '#evidenceTSVLoader';\n        break;\n      case 'csv':\n        joiner = ',';\n        break;\n      default:\n        joiner = '\\t';\n        break;\n    }\n\n    // build the first line from the headers of the table\n    lines.push(headers.join(joiner));\n\n    // continue building lines from each row in the table\n    data.forEach(function(datum,i) {\n      var cells = [];\n      headers.forEach(function(header) {\n        cells.push(datum[header]);\n      });\n      lines.push(cells.join(joiner));\n    });\n\n    // Build the full export string and save it as a blob\n    exportString = lines.join(\"\\n\");\n    blob = new Blob([exportString], {type: \"text/plain;charset=utf-8\"});\n    saveAs(blob, \"ProteomicsCrawler\" + timestamp + \".\" + method);\n  }\n\n}\n\n},{\"./modules/searchBox\":\"/Users/cflynn/Code/proteomics/frontend/public/js/modules/searchBox.js\",\"./modules/table\":\"/Users/cflynn/Code/proteomics/frontend/public/js/modules/table.js\",\"./modules/var\":\"/Users/cflynn/Code/proteomics/frontend/public/js/modules/var.js\"}],\"/Users/cflynn/Code/proteomics/frontend/public/js/modules/addDataset.js\":[function(require,module,exports){\n/**********************************\n * Custom Datasets to back search *\n **********************************/\n\n/**\n * Wrapper function to add custom datasets to Barista so our search\n * box can use them\n */\nfunction addDataset(name, field, type, color){\n  var filterFunction = function(response){\n    var datum_list = [];\n    var auto_data = [];\n    var object_map = {};\n\n    response.forEach(function(element){\n      auto_data.push(element);\n      object_map[element] = element;\n    });\n\n    // make sure we only show unique items\n    auto_data = _.uniq(auto_data);\n\n    // build a list of datum objects\n    auto_data.forEach(function(item){\n      var datum = {\n        value: item,\n        tokens: [item],\n        data: object_map[item]\n      }\n      _.extend(datum,{\n        type: type,\n        search_column: field,\n        color: color,\n      });\n      datum_list.push(datum);\n    });\n\n    // return the processed list of datums for the autocomplete\n    return datum_list;\n  };\n\n  baseObject = {}\n  baseObject[name] = {\n    // only return 4 items at a time in the autocomplete dropdown\n    limit: 10,\n\n    // provide a name for the default typeahead data source\n    name: name,\n\n    // the template to render for all results\n    template: '<span class=\"label\" style=\"background-color: {{ color }}\">{{ type }}</span> {{ value }}',\n\n    // use twitter's hogan.js to compile the template for the typeahead results\n    engine: Hogan,\n\n    remote: {\n      url: '',\n\n      replace: function(url, query){\n        query = (query[0] === \"*\") ? query.replace(\"*\",\".*\") : query;\n        return [proteomicsURL,\n          'q={\"',field,'\":{\"$regex\":\"^',query,'\", \"$options\":\"i\"}}',\n          '&d=',field].join('')\n      } ,\n\n      dataType: 'jsonp',\n\n      filter: filterFunction\n    }\n  }\n  Barista.Datasets = _.extend(Barista.Datasets,baseObject);\n}\n\nmodule.exports = addDataset;\n\n},{}],\"/Users/cflynn/Code/proteomics/frontend/public/js/modules/searchBox.js\":[function(require,module,exports){\nvar addDataset = require('./addDataset');\n\n/*************************\n * Set up the search box *\n *************************/\nfunction build() {\n  configureDatasets();\n\n  /**\n   * searchbox to handle all query inputs\n   * @type {Barista.Views.PertSearchBar}\n   */\n  searchBox = new Barista.Views.PertSearchBar({\n    el: $('#searchBox'),\n    placeholder: 'search by gene',\n    datasets: [\n      Barista.Datasets.ProteomicsGeneNames,\n      Barista.Datasets.ProteomicsProteinNames,\n      Barista.Datasets.ProteomicsModificationNames,\n    ]\n  });\n\n\n  /**\n   * bind the search input to the input handler and typeahead selection events\n   * after giving the code a bit of time to update the DOM\n   */\n\n  appEvents = _.extend({}, Backbone.Events);\n  appEvents.listenTo(searchBox,\"search:DidType\",function(e){\n    handleSearchThrottled(e);\n  });\n}\n\n\nfunction configureDatasets() {\n  addDataset('ProteomicsGeneNames','gene names','Gene','#00ccff');\n  addDataset('ProteomicsProteinNames','protein names','Protein','#ff66cc');\n  addDataset('ProteomicsModificationNames','modifications','Modification','#996600');\n}\n\nmodule.exports = {build:build};\n\n},{\"./addDataset\":\"/Users/cflynn/Code/proteomics/frontend/public/js/modules/addDataset.js\"}],\"/Users/cflynn/Code/proteomics/frontend/public/js/modules/sorters.js\":[function(require,module,exports){\n/**\n * function used to sort the columns in the evidence table\n * @param {event} e    the event passed to the sorter\n * @param {object} args the arguments passed to the sorter from slickgrid\n */\nfunction defaultSorter (e, args,data) {\n  var cols = args.sortCols;\n  data.sort(function (dataRow1, dataRow2) {\n    for (var i = 0, l = cols.length; i < l; i++) {\n      var field = cols[i].sortCol.field;\n      var sign = cols[i].sortAsc ? 1 : -1;\n      var value1 = dataRow1[field], value2 = dataRow2[field];\n      var result = (value1 == value2 ? 0 : (value1 > value2 ? 1 : -1)) * sign;\n      if (result != 0) {\n        return result;\n      }\n    }\n    return 0;\n  });\n}\n\nmodule.exports = {\n  default: defaultSorter\n}\n\n},{}],\"/Users/cflynn/Code/proteomics/frontend/public/js/modules/table.js\":[function(require,module,exports){\nvar sorters = require('./sorters');\n\n/*****************\n * Table methods *\n *****************/\n/**\n * Construct a new table\n * @param {string} DOMtarget The selector to use in targeting the table to the\n *\n * @param {array} columns   an array of objects describing the table columns\n * @param {object} options   an object of slick grid configuration parameters\n * @return {object} an object containing the build table and configuration\n */\nfunction buildTable(DOMtarget,columns,options){\n  var tableObject = {};\n\n  // dataView setup\n  dataView = new Slick.Data.DataView({ inlineFilters: true });\n  tableObject.dataView = dataView;\n\n  // default columns\n  if (columns === undefined) {\n    columns = [\n      { id: \"id\", name: \"ID\", field:\"id\",sortable: true}\n    ]\n  }\n  tableObject.columns = columns;\n\n  // default options\n  if (options === undefined) {\n    options = {\n      enableColumnReorder: false,\n      multiColumnSort: true,\n      forceFitColumns: true,\n    }\n  }\n  tableObject.options = options;\n\n  // build the table\n  tableObject.table = new Slick.Grid(DOMtarget,\n    dataView,\n    columns,\n    options);\n\n  // default the data in the table to an empty array\n  tableObject.data = [];\n\n  // set up table updates\n  tableObject.update = function(data) {\n    updateTable(this,data);\n  }\n\n  // set up table sorting\n  tableObject.table.onSort.subscribe(function (e, args) {\n    sorters.default(e,args,tableObject.data);\n    tableObject.update();\n  });\n\n  return tableObject;\n}\n\n/**\n * updates a table with new data\n * @param {slick grid table} table the table to update\n * @param {array} data  an array of data objects to use as the new data\n * @return {slick grid table} the updated table\n */\nfunction updateTable(table,data) {\n  if (data) {\n    table.data = data;\n  }\n  table.dataView.beginUpdate();\n  table.dataView.setItems(table.data);\n  table.dataView.endUpdate();\n  table.table.invalidate();\n  table.table.render();\n\n  return table;\n}\n\n/**\n * resizes a table based on the data in the table\n * @param {slick grid table} table the table to resize\n */\nfunction resizeTable(table) {\n  var rows = (table.table.getDataLength() > 19) ? 19 : table.table.getDataLength() + 1;\n  $(table.table.getContainerNode()).css('height',rows*25 + 10);\n}\n\nmodule.exports = {\n  buildTable: buildTable,\n  updateTable: updateTable,\n  resizeTable: resizeTable\n}\n\n},{\"./sorters\":\"/Users/cflynn/Code/proteomics/frontend/public/js/modules/sorters.js\"}],\"/Users/cflynn/Code/proteomics/frontend/public/js/modules/var.js\":[function(require,module,exports){\nvar evidenceData = [],\n    pathData = [],\n    datumLists = {},\n    appEvents,\n    handleSearch,\n    handleSearchThrottled,\n    handleSearchErrorMock,\n    handleSearchSuccessMock,\n    proteomicsURL,\n    searchBox,\n    searchString,\n    evidenceTable,\n    evidenceTableColumns,\n    evidenceTableSorter,\n    evidenceTableOptions,\n    evidenceDataView,\n    pathTable,\n    pathTableColumns,\n    pathTableSorter,\n    pathTableOptions,\n    pathDataView;\n\n},{}]},{},[\"./public/js/app.js\"]);\n"],"file":"bundle.js","sourceRoot":"/source/"}